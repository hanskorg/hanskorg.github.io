{"pages":[{"title":"关于我","text":"","link":"/about/index.html"}],"posts":[{"title":"http历史版本特性","text":"http历史版本特性 版本 发行年代 特性 使用情况 http/0.9 1991 GET method only 废弃 http/1.0 1996 头, 缓存,语言 爬虫 http/1.1 1999 keepalive, upgrade,ranges,hosts 流行 SPDY(google过渡版本) 2009 NPN、 单一连接、gzip header、流控制 升级为h2 http/2 2005 ALPN、 HPACK、priorities, server push 流行 (40% 2019) http/3 2018 quic draft 版本发展与现状http/1.1: 传输协议为TCP,可选TLS,为上一代流行http协议版本，通过keepalive实现连接复用,节省了TCP建连时间开销。 http/2: 同样使用TCP作为传输协议，在http1.1时代我们会使用图片拼接、内联分片等优化手段，这是因为http1.1提供keepalive方法做到连接复用，尽量使用减少的连接来传输资源。 然而浏览器复用连接会产生新的问题，http1.x传输方式为队首阻塞(Head of line blocking,)，队列中存在耗时较常操作（协议规定可使用管道复用连接，但大部分浏览器默认关闭）依然会影响整站的加载速度，http/2通过增加一个二进制分帧层 实现多路复用，并报头压缩(SPDY无此特性)、流优先化增加传输效率,详解可参阅 HTTP/2 幕后原理 http2 在实际使用中一般与TLS绑定，但另外有个h2c(http/2 cleartext)版本可以允许客户端不使用https,比如grpc就可以工作在h2c上来减少通信计算压力。 http/3:作为未来版本HTTP-over-QUIC 2018年被IETF接受成为事实上的http/3。不同于之前版本，http/3使用Quic作为控制协议，工作在UDP协议上，天生支持多路复用。http/3简化了https握手过程，并强制使用TLS1.3传输层安全协议目前Chrome(Canary build)、Firefox Nightly 已经支持http/3。HTTP/3最新草案为h3-24。","link":"/http-history/"},{"title":"HTTPS握手","text":"从一份nginx配置谈起 12345678910111213141516171819202122232425262728293031server { listen 443 ssl http2; listen [::]:443 ssl http2; ssl_certificate /path/to/signed_cert_plus_intermediates; ssl_certificate_key /path/to/private_key; ssl_session_timeout 1d; ssl_session_cache shared:MozSSL:10m; # about 40000 sessions ssl_session_tickets off; # curl https://ssl-config.mozilla.org/ffdhe2048.txt &gt; /path/to/dhparam.pem ssl_dhparam /path/to/dhparam.pem; # intermediate configuration ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384; ssl_prefer_server_ciphers off; # HSTS (ngx_http_headers_module is required) (63072000 seconds) add_header Strict-Transport-Security &quot;max-age=63072000&quot; always; # OCSP stapling ssl_stapling on; ssl_stapling_verify on; # verify chain of trust of OCSP response using Root CA and Intermediate certs ssl_trusted_certificate /path/to/root_CA_cert_plus_intermediates; # replace with the IP address of your resolver resolver 127.0.0.1;} ssl_protocols 从协议说起，当前流行的https加密协议包括SSL3.0 TLS1.0 TLS2.0 TLS3.0 TLS(Transport Layer Security 传输层安全协议)是SSL（Secure Sockets Layer 安全套接字）的替换协议。目前协议状态如下 协议 发布时间 状态 SSL 1.0 未发布 安全问题未发布 SSL 2.0 1995年 已于2011年弃用 SSL 3.0 1996年 已于2015年弃用 TLS 1.0 1999年 计划于2020年弃用 TLS 1.1 2006年 计划于2020年弃用 TLS 1.2 1999年 主流协议 TLS 1.3 2008年 主流浏览器已经支持 HTTPS 加密流程采用那种协议需要客户端与服务器协商，考虑到客户端版本滞后的特性，服务器必须支持多种协议，比如上面这份nginx的配置来自Mozilla建议支持TLS1.2、TLS1.3。 Mozilla 这份配置的兼容性 Firefox 27, Android 4.4.2, Chrome 31, Edge, IE 11 on Windows 7, Java 8u31, OpenSSL 1.0.1, Opera 20, and Safari 9 从上面我们已知的HTTPS加密支持TLS、SSL，那么这两种协议差异在哪里？我们该如何选择呢？ TLS 握手 对于现代短连接服务端接口设置一半来说支持TLS1.2 TLS1.3 没有任何问题，探究细节客户端与服务端怎么选择使用那个版本的协议呢？ 这个流程为TLS握手的大致过程，早期的SSL握手过程也差不多，只是更简单点。 [图片来自cloudfare] 参照真实测试了解一下TLS通信过程 12345678910111213141516171819202122232425262728293031➜ ~ curl -I -v https://notes.icool.io* Trying 47.240.72.238...* TCP_NODELAY set* Connected to notes.icool.io (47.240.72.238) port 443 (#0)* ALPN, offering h2* ALPN, offering http/1.1* successfully set certificate verify locations:* CAfile: /etc/ssl/cert.pemCApath: none* TLSv1.2 (OUT), TLS handshake, Client hello (1):* TLSv1.2 (IN), TLS handshake, Server hello (2):* TLSv1.2 (IN), TLS handshake, Certificate (11):* TLSv1.2 (IN), TLS handshake, Server key exchange (12):* TLSv1.2 (IN), TLS handshake, Server finished (14):* TLSv1.2 (OUT), TLS handshake, Client key exchange (16):* TLSv1.2 (OUT), TLS change cipher, Change cipher spec (1):* TLSv1.2 (OUT), TLS handshake, Finished (20):* TLSv1.2 (IN), TLS change cipher, Change cipher spec (1):* TLSv1.2 (IN), TLS handshake, Finished (20):* SSL connection using TLSv1.2 / ECDHE-RSA-AES256-GCM-SHA384* ALPN, server accepted to use h2* Server certificate:* subject: CN=notes.icool.io* start date: Dec 23 08:24:36 2019 GMT* expire date: Mar 22 08:24:36 2020 GMT* subjectAltName: host \"notes.icool.io\" matched cert's \"notes.icool.io\"* issuer: C=US; O=Let's Encrypt; CN=Let's Encrypt Authority X3* SSL certificate verify ok.* Using HTTP2, server supports multi-use* Connection state changed (HTTP/2 confirmed)* Copying HTTP/2 data in stream buffer to connection buffer after 过程解析(TLS1.2为例） 1.密钥交换和密钥协商（1） 客户端发送 ClientHello 客户端随机数（会话密钥）； S1.0 TLS1.1 TLS 1.2；加密套件，比如 ECDHE-ECDSA-AES128-GCM-SHA256 ECDHE-RSA-AES128-GCM-SHA256; 压缩算法；SessionId (会话恢复时使用) 服务端发送 ServerHello 到客户端（2） 服务端随机数；服务端选定的协议版本; 加密方法 2.服务端发送证书（11） 客户端收到证书会使用系统预存CA证书校验证书合法性、过期时间、证书状态等信息 3.服务端发送公钥交换（12） 服务器公钥; 签名（使用RSA私钥签名） 4.服务端握手完成（14） 5.客户端公钥交换（16） 12#客户端生成主密钥,使用公钥加密后发送服务端master_secret = PRF(pre_master_secret, &quot;master secret&quot;,ClientHello.random + ServerHello.random) 6.握手完成 以本次握手为例，稍后通信将使用AES256作为对称加密算法，主密钥做密钥加密通信 ssl_ciphers 不同服务器加密套件选择，建议使用Mozilla建议， https://ssl-config.mozilla.org/#server=nginx&amp;version=1.17.7&amp;config=intermediate&amp;openssl=1.1.1d&amp;guideline=5.4 HSTS（ HTTP严格传输安全） HSTS可以用来抵御SSL剥离攻击,要求浏览器总是使用https访问网站。 OCSP 握手阶段我们提到了，客户端获取证书后需要使用预制的CA校验证书，但这里存在一定风险 – 证书吊销，服务器通过配置ssl_stapling=on通知浏览器做证书在线验证。","link":"/https-handsharke/"},{"title":"跨服务对象存储迁移工具介绍","text":"如果你有多个对象存储数据迁移需求可继续往下看 Introduction 本项目实现了 七牛云存储、阿里云OSS、腾讯COS 对象存储迁移功能 支持多bucket、任务状态保存恢复 使用方法初始化数据库SQL: src/main/resources/transfer.sql配置1### 修改配置 config/application.yml spring: datasource: #mysql 配置 url: jdbc:mysql://localhost:3306/oss_transfer username: root password: 123456 type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver filters: stat maxActive: 20 initialSize: 1 maxWait: 60000 minIdle: 1 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: select 1 testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true maxOpenPreparedStatements: 2mybatis: mapper-locations: classpath:mapping/*.xml type-aliases-package: org.hansk.tools.transfer.domainoss: OSS 配置文件 key: key secret: secret end_point: http://endpoint #endpooint 查看阿里云文档 timeout: 1000 buckets: # bucket列表 testbucket1 testbucket2最大下载数量core_download: 2max_download: 10 qiniu: # 七牛存储配置 access_key: qiniukey secret_key: qiniusecret","link":"/oss-transfer/"},{"title":"一次性密码方案","text":"背景 OTP一次性密码常见于后台登陆，敏感操作的二次验证中，常用方案有HOTP（基于HMAC的一次性密码）、TOTP（基于时间的一次性密码）、短信验证、PUSH验证等，本文只讨论实现成本低的HOTP、TOTP HOTP: HMAC-based One-time Password algorithm 基于散列消息验证码的一次性密码算法 HOTP使用对称验证方式：即验证双方使用相同的Hash算法 H、密钥K、运算值长度，以及“相同”的随机值C，验证双方分别计算得出相同的则验证成功，关于“相同”的随机值C含义后文会介绍。HOTP对于Hash1算法没有特别要求但建议采用SHA-256，密码长度6-10位，建议使用6位或8位，目前市面上常见的二次验证大多采用6位。 名词解释 HMAC:哈希算法 K:密钥 C:随机值（此值验证双方要一致） 实现方式 SHA-1为例子 HMAC(K, C) Hash结果为20字节字符串MAC truncate(MAC) = extract31(MAC, MAC[(19×8) + 4:(19×8)+7] × 8) 最后1个字节的高地址4位表示成整数i，作为下一步截取偏移量。 extract31(MAC, i) = MAC[i+1 : i+(4 × 8)−1] 从原始Hash值中从 i+1到i+(4 × 8)−1 位截取4个bit，结果转成整数，不足6位前面补0。 缺点如果上面计算过程我解释清楚了，那么你应该会有个疑问，K为密钥那么验证双方有记录就可以，C怎么保持一致，正如前文提到C需要相同，一般实现上C采用计数器方式，每次验证后验证双方同时加1，为了容忍一方计数器落后可采用验证方在C±n，即在一个可控范围内验证通过，即便如此工程上实现依旧有难度或者实现不优雅，所以才会有TOTP：基于时间的一次性密码出现。 TOTP: Time-based One-time Password algorithm TOTP一次性密码需要验证端与被验证端时间同步，验证方式与HOTP类似，上面计算过程中的C改为时间戳，下面我们以Google验证器的实现解析TOTP的原理。 Google Authenticator 计算过程123456789function GoogleAuthenticatorCode(string secret) message := floor(current Unix time / 30) hash := HMAC-SHA1(secret, message) offset := last nibble of hash truncatedHash := hash[offset..offset+3] //4 bytes starting at the offset Set the first bit of truncatedHash to zero //remove the most significant bit code := truncatedHash mod 1000000 pad code with 0 from the left until length of code is 6 return code 可以看出计算方式与HOTP一致 我们把floor(current Unix time / 30)记做T，验证端分别使用C = T-1、T、T+1 计算三次，就可以在两端30秒的误差内实现验证一致，从而避免了两端时间不一致造成的验证失败，也使一次性密码的有效期保证最低1分钟有效，实现上只要保证验证双方采用相同的密钥，时间差不超过30秒就能做到一次性密码校验。 开源实现推荐 PHP https://github.com/PHPGangsta/GoogleAuthenticator.git Golang https://github.com/pquerna/otp/totp Rust https://github.com/hanskorg/google-authenticator-rust.git","link":"/一次性密码方案/"},{"title":"UUID 生成服务器搭建","text":"UUID UUID 通用唯一识别ID, 由32位16进制数字组成, 共128 bit, 形式如下。 xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx 由于可靠的长度+可靠算法，UUID能保持1M/s生成速度使用100亿年，UUID生成规则分为4个版本，很多语言都提供了官方或者半官方库,如golang golang.google.com/uuid PHP uuid/guuid。 然而在实际使用中由于位数过长大部分语言只能使用string来表示uuid,使用过程有很多不便,所以我们经常采用一些顺序ID生成算法来替代uuid，其中twitter开源的snowflake就是其中的被经常使用的算法，算法本身很简单，这里不展开希望了解实现过程的话可以参阅 github。 本服务就是SF算法的一个实现，uuid格式为uint64,内网部署接口ns级响应，1s中最多生成1000,000个ID example1curl https://uuid.icool.io/api 环境准备 本安装过程以centos为例 1234567# 安装dockeryum install -y docker docker-compose# 启动dockerservice docker start# 创建依赖目录mkdir -y /data/uuid-server/confmkdir -y /data/uuid-server/sock 基于docker + nginx 的环境搭建 本安装过程假设本地存在nginx,且打算复用本地nginx服务作为uuid-server的服务网关 配置docker-comose.yml 12345678910version: &apos;3&apos;services:uuid-server: image: hansk887/uuid-server:v0.0.5 volumes: - /data/uuid-server/sock:/tmp/uuid-server - /data/uuid-server/conf:/etc/uuid environment: - SOCK=/tmp/uuid-server/unix.sock - ZID=1 # 集群Zone 配置server-id, 单实例本操作可忽略 12345678 echo 1 &gt; /data/uuid-sever/conf/server-id3. 启动服务容器 ```bash docker-compose start #运行docker ps 检查服务启动成功 docker ps # 检查unix socket套接字文件生成成功 ls /data/uuid-server/sock/unix.sock 配置Nginx SCGI转发 1234567server {listen 80;location /uuid { include scgi_params; scgi_pass unix:/data/uuid-server/sock/unix.sock; }} 访问测试 http://localhost/uuid, 正常结果可参照 https://uuid.icool.io docker 独立运行 的环境搭建 本服务镜像包涵独立nginx，编排配置如下 12345678910111213141516171819version: &apos;3&apos;services:uuid-server: image: hansk887/uuid-server:v0.0.5 volumes: - sock:/tmp/uuid-server - /data/uuid-server/conf:/etc/uuid environment: - SOCK=/tmp/uuid-server/unix.sock - ZID=1nginx: image: nginx:latest ports: - &quot;81:80&quot; volumes: - /data/uuid-server/conf/nginx.d:/etc/nginx/conf.d - sock:/tmp/uuid-server volumes:sock: {} 创建配置文件 +– conf | +– nginx.conf | +– server-id +– docker-compose.ymlnginx.conf 配置参照如下: 1234567891011121314151617181920212223242526272829303132333435user nginx;worker_processes 2;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;events { worker_connections 4096;}http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; server { listen 80; location /uuid { include scgi_params; scgi_pass unix:/data/uuid-server/sock/unix.sock; } }} 启动服务容器 12345docker-compose start#运行docker ps 检查服务启动成功docker ps# 检查unix socket套接字文件生成成功ls /data/uuid-server/sock/unix.sock","link":"/uuid-server/"}],"tags":[{"name":"http 协议","slug":"http-协议","link":"/tags/http-协议/"},{"name":"http https handsharke 握手","slug":"http-https-handsharke-握手","link":"/tags/http-https-handsharke-握手/"},{"name":"安全","slug":"安全","link":"/tags/安全/"},{"name":"密码","slug":"密码","link":"/tags/密码/"}],"categories":[{"name":"协议","slug":"协议","link":"/categories/协议/"},{"name":"工具","slug":"工具","link":"/categories/工具/"},{"name":"杂记","slug":"杂记","link":"/categories/杂记/"}]}